3) Keep Django as backend API, build a mobile front-end (best UX)
Create a Django REST API and a proper mobile app (React Native or Flutter).
Backend steps (Django)
1. Add DRF
    pip install djangorestframework djangorestframework-simplejwt
    settings.py:
    INSTALLED_APPS += ['rest_framework']
    REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": ("rest_framework_simplejwt.authentication.JWTAuthentication",)
    }
2. Serializers & Views
    # app/api.py
    from rest_framework import serializers, viewsets
    from .models import Item
    class ItemSerializer(serializers.ModelSerializer):
        class Meta: model = Item; fields = "__all__"
    class ItemViewSet(viewsets.ModelViewSet):
        queryset = Item.objects.all()
        serializer_class = ItemSerializer

3. Routes
    # app/urls.py
    from rest_framework.routers import DefaultRouter
    from .api import ItemViewSet
    router = DefaultRouter(); router.register(r'items', ItemViewSet)
    urlpatterns = router.urls
4. Auth endpoints
    # urls.py
    from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView
    urlpatterns += [
    path('api/token/', TokenObtainPairView.as_view()),
    path('api/token/refresh/', TokenRefreshView.as_view()),
    ]
5. CORS 
    py code
    CORS_ALLOWED_ORIGINS = ["http://localhost:19006","http://localhost:5173"]

React Native quick start
bash code
    npx expo init myapp
    cd myapp
    npx expo install expo-secure-store
    npm install axios
    
Example API call with JWT stored securely:
ts code
    import * as SecureStore from 'expo-secure-store';
    import axios from 'axios';

const api = axios.create({ baseURL: 'https://yourapi.com' });

export async function login(u, p){
  const { data } = await api.post('/api/token/', { username: u, password: p });
  await SecureStore.setItemAsync('access', data.access);
  api.defaults.headers.common.Authorization = `Bearer ${data.access}`;
}
Pros: Best performance & UX, full native APIs.
Cons: New frontend to build.
---------------------------
Cross-cutting concerns (whichever route you choose)
Auth
PWA / WebView: cookies can work if same domain + HTTPS. Otherwise use JWT.
Native (RN/Flutter): JWT, store tokens in secure storage.
File uploads
Use Django endpoints with CSRF exempt if JWT, or properly set CSRF for cookie auth.
Push notifications
PWA: Web Push (limited on iOS).
Capacitor/RN: Use FCM/APNs (e.g., @capacitor/push-notifications or Expo Notifications). Backend sends via FCM/APNs or a service (OneSignal).
Offline
PWA: cache via Service Worker.
Capacitor/RN: local DB (SQLite) + background sync; expose sync endpoints in Django.
Versioning
Version your API (/api/v1/...) to avoid breaking shipped apps.
What I’d recommend
If you need something in app stores this week → Capacitor wrapper.
If you just want “installable” quickly → PWA.
If you want the best long-term product → DRF + React Native (or Flutter).
If you tell me which route you want (PWA, Capacitor, or RN/Flutter), I’ll tailor the exact commands, file structure, and a tiny working template for your app’s stack.