Tailor exact commands for RN/Flutter

Awesome—here are concrete, copy-pasteable tracks to turn your Django app into a Django REST API + React Native (Expo) or Django REST API + Flutter mobile app. Pick one track and follow it top-to-bottom.

Django backend (shared for both RN & Flutter)
# 0) From your Django project root
pip3 install djangorestframework djangorestframework-simplejwt django-cors-headers

# 1) settings.py
INSTALLED_APPS += ["rest_framework", "corsheaders"]
MIDDLEWARE = ["corsheaders.middleware.CorsMiddleware", *MIDDLEWARE]

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    )
}

CORS_ALLOWED_ORIGINS = [
    "http://localhost:19006",  # Expo web preview
    "http://localhost:5173",   # optional web client
    "http://localhost:3000",
    "exp://127.0.0.1:19000",   # Expo
    "http://127.0.0.1:19006",
]
# 2) urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView

# example viewset
from myapp.api import ItemViewSet  # you create this

router = DefaultRouter()
router.register(r"items", ItemViewSet, basename="item")

urlpatterns = [
    path("api/", include(router.urls)),
    path("api/token/", TokenObtainPairView.as_view(), name="token_obtain_pair"),
    path("api/token/refresh/", TokenRefreshView.as_view(), name="token_refresh"),
]
# 3) Example serializer/viewset (myapp/api.py)
from rest_framework import serializers, viewsets, permissions
from .models import Item

class ItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = Item
        fields = "__all__"

class ItemViewSet(viewsets.ModelViewSet):
    queryset = Item.objects.all().order_by("-id")
    serializer_class = ItemSerializer
    permission_classes = [permissions.IsAuthenticated]

# 4) Run server (use 0.0.0.0 if testing on device)
python manage.py runserver 0.0.0.0:8000

Note: For device testing on the same Wi-Fi, use your machine’s LAN IP in the mobile app as the API base URL, e.g., http://192.168.1.10:8000.

Track A — React Native (Expo)
1) Create app
# Node 18+ recommended
npm i -g expo-cli
npx create-expo-app rn-client
cd rn-client
npx expo install expo-secure-store
npm i axios
2) Minimal API client (create src/api.ts)
import axios from "axios";
import * as SecureStore from "expo-secure-store";

const api = axios.create({ baseURL: "http://192.168.1.10:8000" }); // change to your LAN/IP or domain

api.interceptors.request.use(async (config) => {
  const token = await SecureStore.getItemAsync("access");
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});

export async function login(username: string, password: string) {
  const { data } = await api.post("/api/token/", { username, password });
  await SecureStore.setItemAsync("access", data.access);
  await SecureStore.setItemAsync("refresh", data.refresh);
}

export async function refresh() {
  const refresh = await SecureStore.getItemAsync("refresh");
  if (!refresh) return;
  const { data } = await api.post("/api/token/refresh/", { refresh });
  await SecureStore.setItemAsync("access", data.access);
}

export const Items = {
  list: () => api.get("/api/items/").then(r => r.data),
  create: (payload:any) => api.post("/api/items/", payload).then(r => r.data),
};
export default api;

3) App UI (overwrite App.tsx)
import { useEffect, useState } from "react";
import { Button, FlatList, SafeAreaView, Text, TextInput, View } from "react-native";
import { login, Items, refresh } from "./src/api";

export default function App() {
  const [u,setU]=useState(""); const [p,setP]=useState("");
  const [data,setData]=useState<any[]>([]);
  const [loading,setLoading]=useState(false);

  const doLogin = async () => {
    setLoading(true);
    try { await login(u,p); await load(); } finally { setLoading(false); }
  };

  const load = async () => {
    setLoading(true);
    try { setData(await Items.list()); } catch (e) {
      await refresh(); setData(await Items.list());
    } finally { setLoading(false); }
  };

  useEffect(()=>{ /* optionally auto-load if token exists */ },[]);
  return (
    <SafeAreaView style={{flex:1,padding:16}}>
      <Text style={{fontSize:22, fontWeight:"600"}}>Django + RN</Text>
      <View style={{flexDirection:"row", gap:8, marginVertical:12}}>
        <TextInput placeholder="username" onChangeText={setU}
          style={{borderWidth:1,padding:8,flex:1}} />
        <TextInput placeholder="password" secureTextEntry onChangeText={setP}
          style={{borderWidth:1,padding:8,flex:1}} />
        <Button title="Login" onPress={doLogin} />
      </View>
      <Button title={loading?"Loading...":"Load Items"} onPress={load} />
      <FlatList
        data={data}
        keyExtractor={(it)=>String(it.id)}
        renderItem={({item}) => <Text style={{padding:8}}>- {item.name ?? JSON.stringify(item)}</Text>}
      />
    </SafeAreaView>
  );
}

4) Run on device/simulator
npm run start
# press "i" for iOS Simulator (macOS), "a" for Android emulator
# or scan the QR with Expo Go on your phone (same Wi-Fi)
5) Using native features later (example: camera with Expo)
npx expo install expo-image-picker
Then call its APIs in components; uploads hit your Django endpoints.
6) Build store binaries (no native toolchains required)
# create cloud build credentials once
npx expo prebuild --clean # only if you move away from "managed" to "bare" workflow
# Preferred:
npx expo build:android   # or: npx expo run:android for local
npx expo build:ios       # needs Apple dev account


Track B — Flutter
1) Create app
# Node 18+ recommended
npm i -g expo-cli
npx create-expo-app rn-client
cd rn-client
npx expo install expo-secure-store
npm i axios

2) Minimal API client (create src/api.ts)
import axios from "axios";
import * as SecureStore from "expo-secure-store";

const api = axios.create({ baseURL: "http://192.168.1.10:8000" }); // change to your LAN/IP or domain

api.interceptors.request.use(async (config) => {
  const token = await SecureStore.getItemAsync("access");
  if (token) config.headers.Authorization = `Bearer ${token}`;
  return config;
});

export async function login(username: string, password: string) {
  const { data } = await api.post("/api/token/", { username, password });
  await SecureStore.setItemAsync("access", data.access);
  await SecureStore.setItemAsync("refresh", data.refresh);
}

export async function refresh() {
  const refresh = await SecureStore.getItemAsync("refresh");
  if (!refresh) return;
  const { data } = await api.post("/api/token/refresh/", { refresh });
  await SecureStore.setItemAsync("access", data.access);
}

export const Items = {
  list: () => api.get("/api/items/").then(r => r.data),
  create: (payload:any) => api.post("/api/items/", payload).then(r => r.data),
};
export default api;

3) App UI (overwrite App.tsx)
import { useEffect, useState } from "react";
import { Button, FlatList, SafeAreaView, Text, TextInput, View } from "react-native";
import { login, Items, refresh } from "./src/api";

export default function App() {
  const [u,setU]=useState(""); const [p,setP]=useState("");
  const [data,setData]=useState<any[]>([]);
  const [loading,setLoading]=useState(false);

  const doLogin = async () => {
    setLoading(true);
    try { await login(u,p); await load(); } finally { setLoading(false); }
  };

  const load = async () => {
    setLoading(true);
    try { setData(await Items.list()); } catch (e) {
      await refresh(); setData(await Items.list());
    } finally { setLoading(false); }
  };

  useEffect(()=>{ /* optionally auto-load if token exists */ },[]);
  return (
    <SafeAreaView style={{flex:1,padding:16}}>
      <Text style={{fontSize:22, fontWeight:"600"}}>Django + RN</Text>
      <View style={{flexDirection:"row", gap:8, marginVertical:12}}>
        <TextInput placeholder="username" onChangeText={setU}
          style={{borderWidth:1,padding:8,flex:1}} />
        <TextInput placeholder="password" secureTextEntry onChangeText={setP}
          style={{borderWidth:1,padding:8,flex:1}} />
        <Button title="Login" onPress={doLogin} />
      </View>
      <Button title={loading?"Loading...":"Load Items"} onPress={load} />
      <FlatList
        data={data}
        keyExtractor={(it)=>String(it.id)}
        renderItem={({item}) => <Text style={{padding:8}}>- {item.name ?? JSON.stringify(item)}</Text>}
      />
    </SafeAreaView>
  );
}

4) Run on device/simulator
npm run start
# press "i" for iOS Simulator (macOS), "a" for Android emulator
# or scan the QR with Expo Go on your phone (same Wi-Fi)
5) Using native features later (example: camera with Expo)
npx expo install expo-image-picker
Then call its APIs in components; uploads hit your Django endpoints.
6) Build store binaries (no native toolchains required)
# create cloud build credentials once
npx expo prebuild --clean # only if you move away from "managed" to "bare" workflow
# Preferred:
npx expo build:android   # or: npx expo run:android for local
npx expo build:ios       # needs Apple dev account

Track B — Flutter
1) Create app
# Flutter SDK installed and "flutter doctor" is green
flutter create flutter_client
cd flutter_client
flutter pub add dio flutter_secure_storage
2) Minimal API client (lib/api.dart)
import 'package:dio/dio.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class Api {
  final Dio dio = Dio(BaseOptions(baseUrl: 'http://192.168.1.10:8000')); // change IP
  final storage = const FlutterSecureStorage();

  Api() {
    dio.interceptors.add(InterceptorsWrapper(onRequest: (options, handler) async {
      final token = await storage.read(key: 'access');
      if (token != null) options.headers['Authorization'] = 'Bearer $token';
      handler.next(options);
    }));
  }

  Future<void> login(String username, String password) async {
    final res = await dio.post('/api/token/', data: {'username': username, 'password': password});
    await storage.write(key: 'access', value: res.data['access']);
    await storage.write(key: 'refresh', value: res.data['refresh']);
  }
  
    Future<void> refresh() async {
    final refresh = await storage.read(key: 'refresh');
    if (refresh == null) return;
    final res = await dio.post('/api/token/refresh/', data: {'refresh': refresh});
    await storage.write(key: 'access', value: res.data['access']);
  }

  Future<List<dynamic>> listItems() async {
    try {
      final res = await dio.get('/api/items/');
      return res.data as List<dynamic>;
    } on DioException {
      await refresh();
      final res = await dio.get('/api/items/');
      return res.data as List<dynamic>;
    }
  }
}

3) Minimal UI (lib/main.dart)
import 'package:flutter/material.dart';
import 'api.dart';

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(title: 'Django + Flutter', home: Home());
  }
}

class Home extends StatefulWidget {
  @override
  State<Home> createState() => _HomeState();
}

class _HomeState extends State<Home> {
  final api = Api();
  final u = TextEditingController();
  final p = TextEditingController();
  List items = [];
  bool loading = false;

  Future<void> doLogin() async {
    setState(()=>loading=true);
    try { await api.login(u.text, p.text); await load(); }
    finally { setState(()=>loading=false); }
  }

  Future<void> load() async {
    setState(()=>loading=true);
    try { items = await api.listItems(); }
    finally { setState(()=>loading=false); }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Django + Flutter")),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(children: [
          Row(children: [
            Expanded(child: TextField(controller: u, decoration: const InputDecoration(labelText: 'username'))),
            const SizedBox(width: 8),
            Expanded(child: TextField(controller: p, obscureText: true, decoration: const InputDecoration(labelText: 'password'))),
            const SizedBox(width: 8),
            ElevatedButton(onPressed: doLogin, child: const Text('Login')),
          ]),
          const SizedBox(height: 12),
          ElevatedButton(onPressed: load, child: Text(loading ? 'Loading...' : 'Load Items')),
          const SizedBox(height: 12),
          Expanded(child: ListView.builder(
            itemCount: items.length,
            itemBuilder: (_, i) => ListTile(title: Text('- ${items[i]['name'] ?? items[i].toString()}')),
          )),
        ]),
      ),
    );
  }
}
4) Run on device/simulator
flutter run -d ios      # iOS simulator (macOS)
flutter run -d android  # Android emulator/device
5) Add native features later (camera example)
flutter pub add image_picker
Use package API; POST files to your Django upload endpoint.
6) Build release binaries
# Android
flutter build apk --release
# or:
flutter build appbundle --release   # for Play Store

# iOS (on macOS with Xcode + Apple dev account)
flutter build ipa --release
Production notes (both tracks)
Env config: Read base URL from env:
RN (Expo): app.config.ts + Constants.expoConfig?.extra.
Flutter: flutter_dotenv or flavors.
HTTPS: Use HTTPS in production. If you must use self-signed certs on dev, configure network security (Android) / ATS exceptions (iOS) temporarily.
CORS: In production, set CORS_ALLOWED_ORIGINS to your real app domains or deep-link schemes.
Pagination: Prefer DRF pagination and implement ?page= in the clients.
Version your API: serve under /api/v1/....
If you tell me your OS (Windows/macOS/Linux) and whether you prefer Expo RN or Flutter, I’ll tailor the exact base URL, emulator commands, and a ready-to-paste .env setup for your stack.